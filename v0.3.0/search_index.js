var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Array-types","page":"API","title":"Array types","text":"","category":"section"},{"location":"api/#MutableShiftedArrays.MutableShiftedArray","page":"API","title":"MutableShiftedArrays.MutableShiftedArray","text":"MutableShiftedArray(parent::AbstractArray, shifts = (), viewsize=size(v); default = zero(eltype(parent)))\n\nCustom AbstractArray object to store an AbstractArray parent shifted by shifts steps (where shifts is a Tuple with one shift value per dimension of parent). As opposed to ShiftedArray of the ShiftedArrays.jl toolbox, this object is mutable and mutation operations in the padded ranges are ignored. Furthermore it also supports size changes in the view.\n\nFor s::MutableShiftedArray, s[i...] == s.parent[map(-, i, s.shifts)...] if map(-, i, s.shifts) is a valid index for s.parent, and s.v[i, ...] == default otherwise. Use copy to collect the values of a MutableShiftedArray into a normal Array. The recommended constructor is MutableShiftedArray(parent, shifts; default = missing).\n\nnote: Note\nIf parent is itself a MutableShiftedArray with a compatible default value, the constructor does not nest MutableShiftedArray objects but rather combines the shifts additively.\n\nArguments\n\nparent::AbstractArray: the array to be shifted\nshifts::Tuple{Int}: the amount by which parent is shifted in each dimension. The default, an empty Tuple will result in no shifts.\nviewsize::Tuple{Int}: the size of the view. By default the size of the parent array is used.\ndefault::M: the default value to return when out of bounds in the original array. By default zero of the corresponding eltype is used.               Note that using missing as default value will cause single index accesses in CUDA due to the Union type.\n\nExamples\n\njulia> v = [1, 3, 5, 4];\n\njulia> s = MutableShiftedArray(v, (1,))\n4-element MutableShiftedVector{Int64, Int64, Vector{Int64}}:\n 0\n 1\n 3\n 5\n\njulia> copy(s)\n4-element Vector{Int64}:\n 0\n 1\n 3\n 5\n\njulia> v = reshape(1:16, 4, 4);\n\njulia> s = MutableShiftedArray(v, (0, 2), default=missing)\n4×4 MutableShiftedArray{Int64, Missing, 2, Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}}:\n missing  missing  1  5\n missing  missing  2  6\n missing  missing  3  7\n missing  missing  4  8\n\njulia> shifts(s)\n(0, 2)\n\n\n\n\n\n","category":"type"},{"location":"api/#MutableShiftedArrays.MutableShiftedVector","page":"API","title":"MutableShiftedArrays.MutableShiftedVector","text":"MutableShiftedVector{T, S<:AbstractArray}\n\nShorthand for MutableShiftedArray{T, 1, S}.\n\n\n\n\n\n","category":"type"},{"location":"api/#MutableShiftedArrays.CircShiftedArray","page":"API","title":"MutableShiftedArrays.CircShiftedArray","text":"CircShiftedArray(parent::AbstractArray, shifts)\n\nCustom AbstractArray object to store an AbstractArray parent circularly shifted by shifts steps (where shifts is a Tuple with one shift value per dimension of parent). Use copy to collect the values of a CircShiftedArray into a normal Array.\n\nnote: Note\nshift is modified with a modulo operation and does not store the passed value but instead a nonnegative number which leads to an equivalent shift.\n\nnote: Note\nIf parent is itself a CircShiftedArray, the constructor does not nest CircShiftedArray objects but rather combines the shifts additively.\n\nExamples\n\njulia> v = [1, 3, 5, 4];\n\njulia> s = CircShiftedArray(v, (1,))\n4-element CircShiftedVector{Int64, Vector{Int64}}:\n 4\n 1\n 3\n 5\n\njulia> copy(s)\n4-element Vector{Int64}:\n 4\n 1\n 3\n 5\n\n\n\n\n\n","category":"type"},{"location":"api/#MutableShiftedArrays.CircShiftedVector","page":"API","title":"MutableShiftedArrays.CircShiftedVector","text":"CircShiftedVector{T, S<:AbstractArray}\n\nShorthand for CircShiftedArray{T, 1, S}.\n\n\n\n\n\n","category":"type"},{"location":"api/#Shifting-operations","page":"API","title":"Shifting operations","text":"","category":"section"},{"location":"api/#MutableShiftedArrays.lag","page":"API","title":"MutableShiftedArrays.lag","text":"lag(v::AbstractArray, n = 1, viewsize=size(v); default=zero(eltype(v)))\n\nReturn a MutableShiftedArray object which lazily represents the array v shifted by n (an Integer or a Tuple of Integers). If the number of dimensions of v exceeds the length of n, the shift in the remaining dimensions is assumed to be 0. default specifies a default value to return when out of bounds in the original array.\n\nExamples\n\njulia> v = [1, 3, 5, 4];\n\njulia> MutableShiftedArrays.lag(v, default=missing)\n4-element MutableShiftedVector{Int64, Missing, Vector{Int64}}:\n  missing\n 1\n 3\n 5\n\njulia> w = 1:2:9\n1:2:9\n\njulia> s = MutableShiftedArrays.lag(w, 2, default=missing)\n5-element MutableShiftedVector{Int64, Missing, StepRange{Int64, Int64}}:\n  missing\n  missing\n 1\n 3\n 5\n\njulia> copy(s)\n5-element Vector{Union{Missing, Int64}}:\n  missing\n  missing\n 1\n 3\n 5\n\njulia> v = reshape(1:16, 4, 4);\n\njulia> s = MutableShiftedArrays.lag(v, (0, 2), default=missing)\n4×4 MutableShiftedArray{Int64, Missing, 2, Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}}:\n missing  missing  1  5\n missing  missing  2  6\n missing  missing  3  7\n missing  missing  4  8\n\n\n\n\n\n","category":"function"},{"location":"api/#MutableShiftedArrays.lead","page":"API","title":"MutableShiftedArrays.lead","text":"lead(v::AbstractArray, n = 1, viewsize=size(v); default=zero(eltype(v)))\n\nReturn a MutableShiftedArray object which lazily represents the array v shifted negatively by n (an Integer or a Tuple of Integers). If the number of dimensions of v exceeds the length of n, the shift in the remaining dimensions is assumed to be 0. default specifies a default value to return when out of bounds in the original array.\n\nExamples\n\njulia> v = [1, 3, 5, 4];\n\njulia> MutableShiftedArrays.lead(v, default=missing)\n4-element MutableShiftedVector{Int64, Missing, Vector{Int64}}:\n 3\n 5\n 4\n  missing\n\njulia> w = 1:2:9\n1:2:9\n\njulia> s = MutableShiftedArrays.lead(w, 2, default=missing)\n5-element MutableShiftedVector{Int64, Missing, StepRange{Int64, Int64}}:\n 5\n 7\n 9\n  missing\n  missing\n\njulia> copy(s)\n5-element Vector{Union{Missing, Int64}}:\n 5\n 7\n 9\n  missing\n  missing\n\njulia> v = reshape(1:16, 4, 4);\n\njulia> s = MutableShiftedArrays.lead(v, (0, 2), default=missing)\n4×4 MutableShiftedArray{Int64, Missing, 2, Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}}:\n  9  13  missing  missing\n 10  14  missing  missing\n 11  15  missing  missing\n 12  16  missing  missing\n\n\n\n\n\n","category":"function"},{"location":"api/#MutableShiftedArrays.fftshift","page":"API","title":"MutableShiftedArrays.fftshift","text":"fftshift(x [, dims])\n\nLazy version of AbstractFFTs.fftshift(x, dims). Return a CircShiftedArray where each given dimension is shifted by N÷2, where N is the size of that dimension.\n\nExamples\n\njulia> MutableShiftedArrays.fftshift([1 0 0 0])\n1×4 CircShiftedArray{Int64, 2, Matrix{Int64}}:\n 0  0  1  0\n\njulia> MutableShiftedArrays.fftshift([1 0 0; 0 0 0; 0 0 0])\n3×3 CircShiftedArray{Int64, 2, Matrix{Int64}}:\n 0  0  0\n 0  1  0\n 0  0  0\n\njulia> MutableShiftedArrays.fftshift([1 0 0; 0 0 0; 0 0 0], (1,))\n3×3 CircShiftedArray{Int64, 2, Matrix{Int64}}:\n 0  0  0\n 1  0  0\n 0  0  0\n\n\n\n\n\n","category":"function"},{"location":"api/#MutableShiftedArrays.ifftshift","page":"API","title":"MutableShiftedArrays.ifftshift","text":"ifftshift(x [, dims])\n\nLazy version of AbstractFFTs.ifftshift(x, dims). Return a CircShiftedArray where each given dimension is shifted by -N÷2, where N is the size of that dimension.\n\nExamples\n\njulia> MutableShiftedArrays.ifftshift([0 0 1 0])\n1×4 CircShiftedArray{Int64, 2, Matrix{Int64}}:\n 1  0  0  0\n\njulia> MutableShiftedArrays.ifftshift([0 0 0; 0 1 0; 0 0 0])\n3×3 CircShiftedArray{Int64, 2, Matrix{Int64}}:\n 1  0  0\n 0  0  0\n 0  0  0\n\njulia> MutableShiftedArrays.ifftshift([0 1 0; 0 0 0; 0 0 0], (2,))\n3×3 CircShiftedArray{Int64, 2, Matrix{Int64}}:\n 1  0  0\n 0  0  0\n 0  0  0\n\n\n\n\n\n","category":"function"},{"location":"api/#MutableShiftedArrays.circshift","page":"API","title":"MutableShiftedArrays.circshift","text":"circshift(v::AbstractArray, n)\n\nReturn a CircShiftedArray object which lazily represents the array v shifted circularly by n (an Integer or a Tuple of Integers). If the number of dimensions of v exceeds the length of n, the shift in the remaining dimensions is assumed to be 0.\n\nExamples\n\njulia> v = [1, 3, 5, 4];\n\njulia> MutableShiftedArrays.circshift(v, 1)\n4-element CircShiftedVector{Int64, Vector{Int64}}:\n 4\n 1\n 3\n 5\n\njulia> w = reshape(1:16, 4, 4);\n\njulia> MutableShiftedArrays.circshift(w, (1, -1))\n4×4 CircShiftedArray{Int64, 2, Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}}:\n 8  12  16  4\n 5   9  13  1\n 6  10  14  2\n 7  11  15  3\n\n\n\n\n\n","category":"function"},{"location":"api/#Accessor-functions","page":"API","title":"Accessor functions","text":"","category":"section"},{"location":"api/#MutableShiftedArrays.shifts","page":"API","title":"MutableShiftedArrays.shifts","text":"shifts(s::ShiftedArray)\n\nReturn amount by which s is shifted compared to parent(s).\n\n\n\n\n\nshifts(s::CircShiftedArray)\n\nReturn amount by which s is shifted compared to parent(s).\n\n\n\n\n\n","category":"function"},{"location":"api/#MutableShiftedArrays.default","page":"API","title":"MutableShiftedArrays.default","text":"default(s::MutableShiftedArray)\n\nReturn default value.\n\n\n\n\n\n","category":"function"},{"location":"api/#MutableShiftedArrays.ft_center_diff","page":"API","title":"MutableShiftedArrays.ft_center_diff","text":"ft_center_diff(s [, dims])\n\nReturn the shifts required to center dimensions dims at the respective Fourier centers. This function is internally used by MutableShiftedArrays.fftshift and MutableShiftedArrays.ifftshift.\n\nExamples\n\njulia> MutableShiftedArrays.ft_center_diff((4, 5, 6), (1, 2)) # Fourier center is at (2, 3, 0)\n(2, 2, 0)\n\njulia> MutableShiftedArrays.ft_center_diff((4, 5, 6), (1, 2, 3)) # Fourier center is at (2, 3, 4)\n(2, 2, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals","page":"API","title":"Internals","text":"","category":"section"},{"location":"api/#MutableShiftedArrays.padded_tuple","page":"API","title":"MutableShiftedArrays.padded_tuple","text":"padded_tuple(v::AbstractVector, s)\n\nInternal function used to compute shifts. Return a Tuple with as many element as the dimensions of v. The first length(s) entries are filled with values from s, the remaining entries are 0. s should be an integer, in which case length(s) == 1, or a container of integers with keys 1:length(s).\n\nExamples\n\njulia> MutableShiftedArrays.padded_tuple(rand(10, 10), 3)\n(3, 0)\n\njulia> MutableShiftedArrays.padded_tuple(rand(10, 10), (4,))\n(4, 0)\n\njulia> MutableShiftedArrays.padded_tuple(rand(10, 10), (1, 5))\n(1, 5)\n\n\n\n\n\n","category":"function"},{"location":"#MutableShiftedArrays","page":"Introduction","title":"MutableShiftedArrays","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Implementation of shifted arrays just like ShiftedArrays.jl but supporting mutation.","category":"page"},{"location":"#MutableShifted-Arrays","page":"Introduction","title":"MutableShifted Arrays","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A MutableShiftedArray is a lazy view of an Array, shifted on some or all of its indexing dimensions by some constant values.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> v = reshape(1:16, 4, 4)\n4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> s = MutableShiftedArray(v, (2, 0))\n4×4 MutableShiftedArray{Int64, Missing, 2, Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}}:\n  missing   missing    missing    missing\n  missing   missing    missing    missing\n 1         5          9         13\n 2         6         10         14 ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The parent Array as well as the amount of shifting can be recovered with parent and shifts respectively.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> parent(s)\n4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> shifts(s)\n(2, 0)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"shifts returns a Tuple, where the n-th element corresponds to the shift on the n-th dimension of the parent Array.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Use copy to collect the shifted data into an Array:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> copy(s)\n4×4 Matrix{Union{Missing, Int64}}:\n  missing   missing    missing    missing\n  missing   missing    missing    missing\n 1         5          9         13\n 2         6         10         14   ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you pass an integer, it will shift in the first dimension:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> MutableShiftedArray(v, 1)\n4×4 MutableShiftedArray{Int64, Missing, 2, Base.ReshapedArray{Int64, 2, UnitRange{Int64}, Tuple{}}}:\n  missing   missing    missing    missing\n 1         5          9         13\n 2         6         10         14\n 3         7         11         15","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A custom default value (other than missing) can be provided with the default keyword:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> MutableShiftedArray([1.2, 3.1, 4.5], 1, default = NaN)\n3-element ShiftedVector{Float64, Float64, Vector{Float64}}:\n NaN\n   1.2\n   3.1","category":"page"},{"location":"#Out-of-bound-indexes","page":"Introduction","title":"Out of bound indexes","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Accessing indexes outside the MutableShiftedArray give a BoundsError, even if the shifted index would have been valid in the parent array.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> MutableShiftedArray([1, 2, 3], 1)[4]\nERROR: BoundsError: attempt to access 3-element ShiftedVector{Int64, Missing, Vector{Int64}} at index [4]","category":"page"},{"location":"#Shifting-the-data","page":"Introduction","title":"Shifting the data","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Using the MutableShiftedArray type, this package provides two operations for lazily shifting vectors: lag and lead.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> v = [1, 3, 5, 4];\n\njulia> MutableShiftedArrays.lag(v)\n4-element ShiftedVector{Int64, Missing, Vector{Int64}}:\n  missing\n 1\n 3\n 5       \n\njulia> v .- MutableShiftedArrays.lag(v) # compute difference from previous element without unnecessary allocations\n4-element Vector{Union{Missing, Int64}}:\n   missing\n  2\n  2\n -1       \n\njulia> s = MutableShiftedArrays.lag(v, 2) # shift by more than one element\n4-element MutableShiftedVector{Int64, Missing, Vector{Int64}}:\n  missing\n  missing\n 1\n 3","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"lead is the analogous of lag but shifts in the opposite direction:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> v = [1, 3, 5, 4];\n\njulia> MutableShiftedArrays.lead(v)\n4-element ShiftedVector{Int64, Missing, Vector{Int64}}:\n 3\n 5\n 4\n  missing","category":"page"}]
}
